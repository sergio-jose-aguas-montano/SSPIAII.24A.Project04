setwd("D:/0 Escuela/8vo/SSPIA2/Equipo final/SSPIAII.24A.Project04")
source("Análisis descriptivo.R")
#Modelo regresion logistica
mdl.Rlog <- glm(formula = Fecha ~ Producto,
data = df.Ventas.Train)
summary(mdl.Rlog)
#Prediccion
predict.Ventas <- predict(mdl.Rlog, type = "response",
newdata = df.Ventas.Test)
predict.Ventas
Y.pred <- ifelse(predict.Ventas >= 0.5, 1, 0)
Y.pred
#Grafica
plt.Ventas <- ggplot()+
theme_light()+
ggtitle("Regresion: Fecha vs Producto")+
xlab("Producto")+
ylab("Fechas")
plt.Ventas.g <- plt.Ventas+
geom_point(aes(x = df.Ventas.Train$Producto,
y = df.Ventas.Train$Fecha),
colour = "blue")+
geom_line(aes(x = df.Ventas$Producto,
y = predict(mdl.Rlog,
newdata = df.Ventas)),
colour = "coral")
plt.Ventas.g
source("Análisis descriptivo.R")
#Modelo de K-means
mdl.NSup <- kmeans(df.Ventas.Train, 7, trace = T)
#Elbow (Saber cantidad de clusters)
n.obs <- length(df.Ventas.Train$Categoria)
#Y - wcss
#X - Númeroclusters
wcss <- vector()
for (i in 1:15) {
wcss[i] <- kmeans(df.Ventas.Train, i)$tot.withinss
}
wcss <- as.data.frame(wcss)
wcss$k <- seq(1,15,1) #Del 1 al 15, contando de 1 en 1
#Graficación del método del codo para ver la curvatura para saber el número de clusters necesarios
ggplot()+
geom_line(aes(x = wcss$k,
y = wcss$wcss))+
geom_point(aes(x = wcss$k,
y = wcss$wcss,
color = wcss$k))+
ggtitle("Método del codo")+
xlab("Iteración")+
ylab("WCSS")+
theme_light()
#Uso de ggplot base para representar los cluster, básico solo mandar la información de x y y en el plano junto con el modelo para los puntos
ggplot(df.Ventas.Train, aes(x = PrecioUnidad, y = Producto)) +
geom_point(aes(color = as.factor(mdl.NSup$cluster))) +
labs(title = "Relacion de Producto y precio por unidad", x = "Precio por unidad", y = "Producto", color = "Cluster") +
theme_minimal()
source("Preprocesamiento.R")
#Correlacion para ver que relacion tienes las categorias
cor.ventas <- cor(df.Ventas)
#Exporacion de minimo, maximo, media
Summ.ventas <- summary(df.Ventas)
#Boxplot para ver los cuartiles y si hay datos desplazados
boxplot(df.Ventas$Producto)
boxplot(df.Ventas$Categoria)
boxplot(df.Ventas$Cantidad)
boxplot(df.Ventas$PrecioUnidad)
boxplot(df.Ventas$PrecioFinal)
boxplot(df.Ventas$Dinero.recibido)
boxplot(df.Ventas$Horario)
boxplot(df.Ventas$Dia)
boxplot(df.Ventas$Fecha)
boxplot(df.Ventas$Personal)
boxplot(df.Ventas$local)
boxplot(df.Ventas$Venta)
#Escalado de los datos por el sego que tienen en la boxplot
#df.Ventas$Cantidad <- scale(df.Ventas$Cantidad)
#df.Ventas$PrecioUnidad <- scale(df.Ventas$PrecioUnidad)
#df.Ventas$PrecioFinal <- scale(df.Ventas$PrecioFinal)
#df.Ventas$Dinero.recibido <- scale(df.Ventas$Dinero.recibido)
#df.Ventas$Cantidad<- as.numeric(df.Ventas$Cantidad)
#df.Ventas$PrecioUnidad<- as.numeric(df.Ventas$PrecioUnidad)
#df.Ventas$PrecioFinal<- as.numeric(df.Ventas$PrecioFinal)
#df.Ventas$Dinero.recibido<- as.numeric(df.Ventas$Dinero.recibido)
#Divicion de los datos para el modelado y graficado
Split <- sample.split(df.Ventas$Venta, SplitRatio = 0.8)
df.Ventas.Train <- subset(df.Ventas, Split == T)
df.Ventas.Test <- subset(df.Ventas, Split == F)
#Graficacion para ver los datos dependiendo de 2 variables
plot(df.Ventas.Train$Fecha)
with(df.Ventas.Train,plot(Fecha,Producto))
#Graficacion para ver los datos dependiendo de 2 variables
plot(df.Ventas.Train)
#Graficacion para ver los datos dependiendo de 2 variables
plot(df.Ventas.Train$Fecha)
summary(predict.Ventas)
summary(mdl.Rlog)
install.packages("pscl")
library(pscl)
pR2(mdl.Rlog)
LL_null <- logLik(glm(formula = Fecha ~ 1, data = df.Ventas.Train))
# Calcular log-verosimilitud para el modelo ajustado
LL_model <- logLik(mdl.Rlog)
# Calcular pseudo R^2 de McFadden
R2_pseudo_McFadden <- 1 - (LL_model / LL_null)
# Imprimir el pseudo R^2 de McFadden
print(R2_pseudo_McFadden)
summary(mdl.Rlog)
source("Análisis descriptivo.R")
#Modelo regresion logistica
#2 tipos
#Se utiliza el modelo de entrenamiento y se fija una variable objetivo (PrecioUnidad)
tsk = makeRegrTask(data = df.Ventas.Train, target = "PrecioUnidad")
source("Análisis descriptivo.R")
#Modelo regresion logistica
#2 tipos
#Se utiliza el modelo de entrenamiento y se fija una variable objetivo (PrecioUnidad)
tsk = makeRegrTask(data = df.Ventas.Train, target = "PrecioUnidad")
source("Preprocesamiento.R")
#Correlacion para ver que relacion tienes las categorias
cor.ventas <- cor(df.Ventas)
#Exporacion de minimo, maximo, media
Summ.ventas <- summary(df.Ventas)
#Boxplot para ver los cuartiles y si hay datos desplazados
boxplot(df.Ventas$Producto)
boxplot(df.Ventas$Categoria)
boxplot(df.Ventas$Cantidad)
boxplot(df.Ventas$PrecioUnidad)
boxplot(df.Ventas$PrecioFinal)
boxplot(df.Ventas$Dinero.recibido)
boxplot(df.Ventas$Horario)
boxplot(df.Ventas$Dia)
boxplot(df.Ventas$Fecha)
boxplot(df.Ventas$Personal)
boxplot(df.Ventas$local)
boxplot(df.Ventas$Venta)
#Escalado de los datos por el sego que tienen en la boxplot
#df.Ventas$Cantidad <- scale(df.Ventas$Cantidad)
#df.Ventas$PrecioUnidad <- scale(df.Ventas$PrecioUnidad)
#df.Ventas$PrecioFinal <- scale(df.Ventas$PrecioFinal)
#df.Ventas$Dinero.recibido <- scale(df.Ventas$Dinero.recibido)
#df.Ventas$Cantidad<- as.numeric(df.Ventas$Cantidad)
#df.Ventas$PrecioUnidad<- as.numeric(df.Ventas$PrecioUnidad)
#df.Ventas$PrecioFinal<- as.numeric(df.Ventas$PrecioFinal)
#df.Ventas$Dinero.recibido<- as.numeric(df.Ventas$Dinero.recibido)
#Divicion de los datos para el modelado y graficado
Split <- sample.split(df.Ventas$Venta, SplitRatio = 0.8)
df.Ventas.Train <- subset(df.Ventas, Split == T)
df.Ventas.Test <- subset(df.Ventas, Split == F)
#Graficacion para ver los datos dependiendo de 2 variables
plot(df.Ventas.Train$Fecha)
with(df.Ventas.Train,plot(Fecha,Producto))
source("Análisis descriptivo.R")
#Modelo regresion logistica
#2 tipos
#Se utiliza el modelo de entrenamiento y se fija una variable objetivo (PrecioUnidad)
tsk = makeRegrTask(data = df.Ventas.Train, target = "PrecioUnidad")
source("Análisis descriptivo.R")
#Modelo regresion logistica
#2 tipos
#Se utiliza el modelo de entrenamiento y se fija una variable objetivo (PrecioUnidad)
tsk = makeRegrTask(data = df.Ventas.Train, target = "PrecioUnidad")
#Tambien se utiliza el modelo de testeo
tskTest = makeRegrTask(data = df.Ventas.Test, target = "PrecioUnidad")
#lista creada por makeLearner
base = c("regr.rpart", "regr.svm","regr.randomForest")
#lapply nos devuelve una lista despues de aplicar una funcion a sus elementos
lrns = lapply(base, makeLearner)
#se utiliza la prediciion base y se utiliza las siguientes predicciones como acracteristicas para un resultado
m = makeStackedLearner(base.learners = lrns,
predict.type = "response", method = "compress")
tmp <- train(m, tsk)
res <- predict(tmp, tskTest)
#Grafica
plt.Ventas <- ggplot()+
theme_light()+
ggtitle("Regresion: Precio vs Dia")+
xlab("Dia")+
ylab("Precio")
#Grafica utilizando las variables de Fecha y Precio por unidad
plt.Ventas.g <- plt.Ventas+
geom_point(aes(x = df.Ventas.Test$Fecha,
y = df.Ventas.Test$PrecioUnidad),
colour = "blue")+
geom_line(aes(x = df.Ventas.Test$Fecha,
y = res$data$response),
colour = "coral")
plt.Ventas.g
predicciones <- res$data$response
# Valores reales
valores_reales <- df.Ventas.Test$PrecioUnidad
# Calcular la suma de los cuadrados totales (SCT)
sct <- sum((valores_reales - mean(valores_reales))^2)
# Calcular la suma de los cuadrados de los residuos (SCR)
scr <- sum((valores_reales - predicciones)^2)
# Calcular el R cuadrado
r_cuadrado <- 1 - (scr / sct)
# Número de observaciones
n <- length(valores_reales)
# Número de predictores (en este caso, solo tienes un modelo)
p <- 1
# Calcular el R cuadrado ajustado
r_cuadrado_ajustado <- 1 - (1 - r_cuadrado) * ((n - 1) / (n - p - 1))
# Mostrar los resultados
print(paste("R cuadrado:", r_cuadrado))
print(paste("R cuadrado ajustado:", r_cuadrado_ajustado))
